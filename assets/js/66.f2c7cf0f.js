(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{495:function(t,e,a){"use strict";a.r(e);var r=a(1),v=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"kafka"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#kafka"}},[t._v("#")]),t._v(" KAFKA")]),t._v(" "),e("h2",{attrs:{id:"topic"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#topic"}},[t._v("#")]),t._v(" Topic")]),t._v(" "),e("p",[t._v("Data 모음")]),t._v(" "),e("h2",{attrs:{id:"event-queue-message-queue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#event-queue-message-queue"}},[t._v("#")]),t._v(" EVENT Queue / MESSAGE Queue")]),t._v(" "),e("blockquote",[e("p",[t._v("Event queue와 Message queue와의 차이점")])]),t._v(" "),e("p",[t._v("event queue는 "),e("strong",[t._v("비 휘발성")]),t._v("을 가진다")]),t._v(" "),e("p",[t._v("queue에 한 번 쌓인 데이터의 경우 "),e("strong",[t._v("offset")]),t._v("을 가지고 데이터를 읽어 내린다.")]),t._v(" "),e("p",[t._v("반면 "),e("strong",[t._v("Message queue")]),t._v("의 경우에는 현재 Queue에 있는 가장 먼저 들어온 데이터를 읽어 내린다.(휘발성)")]),t._v(" "),e("p",[t._v("이러한 문제를 보완하기위해서는 Message Queue의 경우 별도의 플러그인이나 구현이 필요하다.")]),t._v(" "),e("h2",{attrs:{id:"pub-producer-sub-consumer"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pub-producer-sub-consumer"}},[t._v("#")]),t._v(" Pub(Producer) / Sub(Consumer)")]),t._v(" "),e("p",[t._v("공급자 / 소비자")]),t._v(" "),e("h2",{attrs:{id:"broker"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#broker"}},[t._v("#")]),t._v(" Broker")]),t._v(" "),e("p",[t._v("카프카가 설치되어 있는 서버의 단위")]),t._v(" "),e("h2",{attrs:{id:"replication"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#replication"}},[t._v("#")]),t._v(" replication")]),t._v(" "),e("p",[t._v("replication은 브로커 내부에 존재한다고 볼수 있다. 그렇기에 Broker의 갯 수를 상위할 수 없다.")]),t._v(" "),e("p",[t._v("고가용성에 도움을 준다.")]),t._v(" "),e("p",[t._v("파티션의 복제를 의미한다.")]),t._v(" "),e("h2",{attrs:{id:"partition"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#partition"}},[t._v("#")]),t._v(" Partition")]),t._v(" "),e("p",[t._v("partition Leader partition이 최초로 Topic을 수용하고, 이를 Follower partition에 분배한다.")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("ack= 0 리더 파티션에 topic을 전송하고, 전송 여부는 확인하지 않는다.")])]),t._v(" "),e("li",[e("p",[t._v("ack= 1 리더 파티션에 topic을 전송하고, 전송 여부를 확인한다.")])]),t._v(" "),e("li",[e("p",[t._v("ack= all 리더 파티션에 데이터를 보내고 Follower 파티션에 정상적으로 전송됐는지 여부도 확인한다.")])])]),t._v(" "),e("h2",{attrs:{id:"partitioner"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#partitioner"}},[t._v("#")]),t._v(" Partitioner")]),t._v(" "),e("p",[t._v("record의 key 와 값에 따라서 다르게 동작한다.")]),t._v(" "),e("p",[t._v("모든 프로듀서의 "),e("strong",[t._v("topic은 파티셔너를 거쳐서 Broker에 메세지를 전달")]),t._v("한다.")]),t._v(" "),e("p",[t._v("동일한 Messege key를 가진 Topic은 항상 동일한 Partition에 들어가게 된다.")]),t._v(" "),e("p",[t._v("messega key가 없다면 round-robin 방식으로 분배된다.")]),t._v(" "),e("p",[t._v("파티셔너는 커스텀도 가능하다.(토픽 이름, 값 키 등을 커스텀 가능)")]),t._v(" "),e("h2",{attrs:{id:"lag"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lag"}},[t._v("#")]),t._v(" LAG")]),t._v(" "),e("p",[t._v("토픽의 파티션에 저장된 "),e("strong",[t._v("Data의 offset은 index개념으로 Data의 순서대로 Offset")]),t._v(" 번호를 할당한다.")]),t._v(" "),e("p",[t._v("읽은(Consumer) offset과 현재 공급(Producer) offset간의 차이가 lag이다.")]),t._v(" "),e("p",[t._v("이중 높은 숫자의 렉이 "),e("strong",[t._v("Record-lag-mex")]),t._v("라고 부른다.")]),t._v(" "),e("h2",{attrs:{id:"monitoring"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#monitoring"}},[t._v("#")]),t._v(" Monitoring")]),t._v(" "),e("p",[t._v("커슈머에서 Lag을 측정하는 것은 어려움")]),t._v(" "),e("p",[t._v("레이턴시나 수집으로 인한 장애가 발생할 우려가 있음")]),t._v(" "),e("p",[t._v("이러한 모니터링을 위해서 Burrow가 있다")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("멀티 카프카 클러스터 지원")])]),t._v(" "),e("li",[e("p",[t._v("status 기반의 관리")])]),t._v(" "),e("li",[e("p",[t._v("HTTP API 제공")])])])])}),[],!1,null,null,null);e.default=v.exports}}]);